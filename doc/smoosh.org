# -*- mode: org -*-
#+TITLE: Smoosh
#+STARTUP: showall
#+FILETAGS: :go:meetup:
#+SETUPFILE: ~/o/theme.org

* Overview

Monkey is the language used in a book called 'Writing an interpreter in Go'.

Please read the book. It's amazingly clear, and good fun.

The language itself is amazing because it's written entirely using Go's standard library, it's easy to understand and yet it has some advanced language features (e.g. closures). Note that it's still a toy though - e.g. weak error-handling and some fundamental features are missing.

Note that it's not necessary to be an expert on compilers to enjoy this book. I've never studied compilers, I enjoy learning-by-doing, and I believe that this learning goal is acheivable with good resources. That's kind of the point of this talk.

The book itself is copyrighted _but_ the code is MIT licensed, so I'm going to base my talk on the Monkey code and my changes to it.

 - I'll talk about the high-level building blocks of an interpreter.
 - I'll try to explain what problem Smoosh is trying to solve.
 - Review some Smoosh code, to help illustrate the different parts of the system.
 - Hopefully, add a feature with some live coding

Along the way I'll try to show what Go gives us to help make this all kinda easy.

* Interpeter vs compiler; what's a shell?

** Compiler vs interpreter
  - An interpreter directly executes instructions rather than compiling them to machine code in advance.
  - Some platforms offer an interpreter AND a compiler (~go run~, anyone?) - the difference is a bit blurry.
  - Several varieties of interpreter. We'll just look at the style used in Monkey.
  - Monkey executes precompiled code using an intermediate representation called an AST - ASTs are more often used in Compiled languages, e.g. Go itself

** What's a shell
  - Shells are varied and broad in scope
  - For this talk, let's define a shell as:
    - A shell is fundamentally an interpeter which is convenient for chaining executables together in a pipeline
    - A shell only needs a basic type system:
      - Strings, numbers, bools, maps, arrays
      - (i.e. no User-Defined types)
      - I/O streams
    - First-class support for I/O pipelines

** What's the problem?
  - Programming languages are great for defining business logic, but a little inconvenient as a pipeline for shell-like pipelines
  - Shells can be awkward for defining business logic. If statements are tricky, functions are limited, data types are limited

** Solution?
   - Smoosh is an early-stage prototype for a programmer's shell
   - Attempting to make a language which is convenient for writing shell scripts (piping commands together) and also programming
   - More focused on shell scripts than an interactive shell, but still provides an interactive REPL
   - A bit like Go:
     - Easy to read
     - Small and easy to grok
     - Type checking w type inference
     - gofmt for consistency
     - Closures and functions
     - Rich standard library

* Our Interpreter: Smoosh

Smoosh is basically the same as Monkey in terms of structure and approach to interpreting code.

** flow diagram

#+BEGIN_SRC dot :file smoosh.svg :cmdline -Kdot -Tsvg
digraph Smoosh {
    rankdir="LR";
    node[shape=rectangle];
    edge[weight=2];
    Lexer[shape=cds];
    Parser[shape=cds];
    Evaluation[shape=cds];
    REPL[shape=cds];
    subgraph cluster1 {
       label="Phases"
       Lexer -> Parser;
       Parser -> Evaluation;
       Evaluation -> REPL;
    }
    Source[shape=cylinder];
    Tokens[shape=cylinder];
    AST[shape=cylinder];
    Object[shape=cylinder];
    subgraph cluster2 {
       label="Representations"
       Source -> Tokens [label=lexing];
       Source ->Lexer [style=dashed];
       Tokens->AST [ label=parsing ];
       Lexer ->Tokens [style=dashed];
       Tokens -> Parser [style=dashed];
       Parser -> AST [style=dashed];
       AST->Object [ label=evaluation ];
    }
    edge[weight=1];
}
#+END_SRC

#+RESULTS:
[[file:smoosh.svg]]

** Packages

This diagram generated by 'godepgraph' shows the simplicity of the Monkey/Smoosh interpreter

[[file:smooshpkgs.svg]]

** Smoosh on github
   https://github.com/laher/smoosh

   See README for project status

* Monkey vs Go compiler
  Monkey/Smoosh is similar to the Go compiler up to a point.
  - The Go compiler first tokenizes code
  - The Go compiler is written in Go too!
  - The Go compiler constructs an AST.
  - BUT, the go compiler generates machine code, it has a formal grammar (goyacc), it uses an intermediate form called SSA, and runs various optimisations.
  - https://github.com/golang/go/blob/master/src/cmd/compile/README.md
  - old compiler (gccgo) https://talks.golang.org/2015/keeping-up/gccgo_structure.png
  - AST: https://arslan.io/2017/09/14/the-ultimate-guide-to-writing-a-go-tool/
  - SSA: https://about.sourcegraph.com/go/generating-better-machine-code-with-ssa/

* Phases of the interpreter

** Tokenizing
  - '[[https://en.wikipedia.org/wiki/Lexical_analysis][Lexical analysis]]' (lexing) / Tokenizing is the first stage of modern compiler processing.
  - Typically you pass through the source once.
  - the result is an ordered list of 'tokens' without any structure.
  - e.g. it doesn't verify that an 'if ... {' has a matching '}'.
  - See [[https://github.com/laher/smoosh/blob/master/token/token.go][token.go]] and [[https://github.com/laher/smoosh/blob/master/lexer/lexer.go][lexer.go]]

** Parsing
  - [[https://en.wikipedia.org/wiki/Parsing#Computer_languages][Parsing]] is the component which defines a structured representation of the code.
  - Monkey represents structure as an [[https://en.wikipedia.org/wiki/Abstract_syntax_tree][Abstract Syntax Tree]]
  - The strategy used is called a [[https://en.wikipedia.org/wiki/Recursive_descent_parser][Recursive Descent Parser]], specifically a [[https://en.wikipedia.org/wiki/Pratt_parser][Pratt Parser]].
  - Parsers are often automatically generated from declarative markup, using a 'parser generator' - see yacc, bison, antlr, goyacc
  - Parser generators are really useful for completeness, correctness, and treating edge cases, but you don't learn as much. Therefore -> we code this parser manually.
  - AST: hierarchy is defined as infix and postfix expressions
  - See [[https://github.com/laher/smoosh/blob/master/ast/ast.go][ast.go]]and [[https://github.com/laher/smoosh/blob/master/parser/parser.go][parser.go]]

** Evaluation
  - Processes AST statements and expressions
  - Monkey/Smoosh stores state in 'Environment' maps
  - Executes precompiled code
  - Harnesses Go's garbage collector
  - See [[https://github.com/laher/smoosh/blob/master/evaluator/evaluator.go][evaluator.go]], [[https://github.com/laher/smoosh/blob/master/evaluator/builtins.go][builtins.go]]
  - For runtime state representation, see [[https://github.com/laher/smoosh/blob/master/object/object.go][object.go]] and [[https://github.com/laher/smoosh/blob/master/object/environment.go][environment.go]]

** Runner
  - Monkey offers a REPL for each phase during each chapter.
  - I've combined them so you can observe the output of each phase using different options
  - I also added a second mode of operation - a 'file runner'
  - See [[https://github.com/laher/smoosh/blob/master/run/runner.go][runner.go]]

* Tooling
  - REPL flavours
  - Formatting code
  - End-to-end testing

* Code samples
  Let's cover at least 3 of these
  - Adding a new token - E.g. one-line comments
  - Add a builtin function, e.g. ~cd~
  - Adding 'piping'
  - Adding type-checking - ~let~ -> ~var~ (like go); check existing Objects during eval
  - Adding some syntax - 'for-range loops'
  - Building a standard library akin to Go's stdlib
  - Unicode support

* Add features?
  If we have time, let's try some live-coding of Smoosh
** Write some end-to-end tests
   - One good, one bad.
   - Make them pass
** Examples to choose from
  - A new stdlib function
  - Backticks for some more concise command invocation
  - Handling exit codes
  - Floats
